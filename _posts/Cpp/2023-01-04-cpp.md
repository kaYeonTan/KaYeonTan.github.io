---
title:  "Set"
excerpt: ""

categories:
  - cpp
tags:
  - [Cpp, C++]

toc: true
toc_sticky: true
 
date: 2023-01-04
last_modified_at: 2023-01-04
---

#### List    
---

<https://losskatsu.github.io/programming/c-stl-list/#> 참고  
<https://jhnyang.tistory.com/377> 참고  

<br>
<br>   

##### List란  

vector, 배열 처럼 데이터를 저장하기 위한 자료구조의 일종이다.  
STL 라이브러리의 List는 양방향 링크 방식으로 구현되어있다.   

<br>
<br>

##### List의 사용법      

다음과 같이 헤더파일을 쓰면 된다.  

```cpp
#include <list>
```

- 기본 선언문  
    `list<자료형> [ 변수이름 ];`

```cpp
list<int> list1;
list<char> list2;
list<string> list3;
```

이런식으로 리스트를 선언할 수 있다.
꺽새 안에 들어간 자료형 타입으로 선언한다.  

- 선언 초기화  
    `list<자료형> [ 변수이름 ] (개수);`

```cpp
#include <iostream>
#include <list>
using namespace std;

int main()
{
	int n = 5;
	list<int>  intList(n);
	list<char> charList(3);

	for (int i : intList)		printf("%d, ", i);

	cout << endl;

	for (char i : charList)		printf("%c, ", i);

	cout << endl;

	return 0;
}
```

```
output

0, 0, 0, 0, 0,
, , ,
```

int의 디폴트 값은 0, char의 디폴트 값은 ''이다.  

- 특정 값으로 초기화  
    `list<자료형> [ 변수이름 ] (개수, 값);`

```cpp
#include <iostream>
#include <list>
using namespace std;

int main()
{
	int n = 5;
	list<int>  intList(n, 2);

	for (int i : intList)		printf("%d, ", i);

	return 0;
}
```

```
output

2, 2, 2, 2, 2,
```

모두 2로 초기화 된 것을 확인할 수 있다.  

<br>
<br>

##### set의 멤버 함수  

1. set<int> s; 기준으로 작성하였다.  
2. set<int>::iterator iter, start, end; 로 반복자 세 개 선언하였다.
3. int k 는 원소이다.  

- s.begin();  
    - 맨 첫번째 원소를 가리키는 반복자를 리턴(참조)한다.  
    - iter = s.begin(); 으로 사용한다.  

- s.end();  
    - 맨 마지막 원소(의 다음)를 가리키는 원소의 끝부분을 알 때 사용한다.  
    - 반복자를 리턴(참조)한다.  
    - iter = s.end();  

- s.rbegin();  
- s.rend();  
    - r은 reverse를 의미한다.  
    - begin(), end() 와 반대로 작동하는 멤버함수이다.  
    - 역으로 출력하고 싶을때 사용한다.  
    - 아래와 같이 사용한다.  

    ```cpp
    for(iter = s.rbegin();iter!=s.rend();iter++)
    {
        cout<<*iter<<endl;
    }
    ```  

- s.clear();  
    - 모든 원소를 제거한다.  

- s.count(k);
 - 원소 k 의 개수를 반환한다.  

- s.empty();  
    - set s가 비어있는지 확인한다.  

- s.insert(k);  
    - 원소 k를 삽입한다.  
    - 삽입시에 자동으로 정렬된 위치에 삽입된다.  
    - 삽입이 성공 실패에 대한 여부는 리턴값 (pair<iterator, bool>) 으로 나온다.  
    - pair<iterator, bool>에서 pair.first는 삽입한 원소를 가리키는 반복자 이고, pair.second는 성공(true), 실패(false)를 나타낸다.  

- s.insert(iter, k);  
    - iter가 가리키는 위치 부터 k를 삽입할 위치를 탐색하여 삽입한다.  

- s.erase(iter);  
    - iter가 가리키는 원소를 제거한다.    
    - 제거 한다음 제거 한 원소 다음 원소를 가리키는 반복자를 리턴한다.  

- s.erase(start, end);  
    - [start, end) 범위의 원소를 모두 제거한다.  

- s.find(k);
    - 원소 k를 가리키는 반복자를 반환한다.  
    - 원소 k가 없다면 s.end() 와 같은 반복자를 반환한다.  

- s2.swap(s1);
    - s1과 s2를 바꿔준다.  

- s.upper_bound(k);
    - 원소 k가 끝나는 구간의 반복자 이다.  

- s.lower_bound(k);
    - 원소 k가 시작하는 구간의 반복자 이다.  

- s.equal_range(k);    
    - 원소 k가 시작하는 구간과 끝나는 구간의 반복자 pair 객체를 반환한다.  
    - upper_bound(k), lower_bound(k) 가 합쳐진 멤버함수이다.  

- s.value_comp();

- s.key_comp();
    - 정렬 기준 조건자를 반환한다.  
    - set 컨테이너에서는 두개의 함수 반환형이 같다.  

- s.size();
    - 사이즈(원소의 갯수)를 반환한다.  

- s.max_size();
    - 최대 사이즈(남은 메모리 크기)를 반환한다.  

<br>
<br>

##### 예제  

```cpp
#include <iostream>
#include <set>

using namespace std;

int main(void)
{
	set<int> s;

	s.insert(1);
	s.insert(4);
	s.insert(7);
	s.insert(2);
	s.insert(3);
	s.insert(5);
	s.insert(6);
	s.insert(8);

	set<int>::iterator i;
	for (i = s.begin(); i != s.end(); i++)
	{
		cout << *i << "  ";
	};
	cout << endl;

	//출력값 : 1  2  3  4  5  6  7  8

	//중복된 값 넣기
	s.insert(2);
	for (i = s.begin(); i != s.end(); i++)
	{
		cout << *i << "  ";
	};
	cout << endl;
	//출력값 : 1  2  3  4  5  6  7  8

	//존재하는 원소 찾기
	i = s.find(2);
	if (i != s.end()) cout << *i << " 존재" << endl;
	else cout << "존재하지 않음" << endl;

	//출력값 : 2 존재

	//존재하지 않는 원소찾기
	i = s.find(10);
	if (i != s.end()) cout << *i << " 존재" << endl;
	else cout << "존재하지 않음" << endl;

	//출력값 : 존재하지 않음
}
```

```
output

1  2  3  4  5  6  7  8
1  2  3  4  5  6  7  8
2 존재
존재하지 않음
```
~~예제 연습 더하기~~